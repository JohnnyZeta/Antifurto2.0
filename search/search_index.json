{"config":{"lang":["it"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Come sanno coloro che frequentano il canale Slack SmartHome con il sottoscritto, di recente ho dovuto procurarmi un nuovo sistema di antifurto per la nuova casa in cui vivo. Tralascer\u00f2 le tribolazioni che ho dovuto superare per trovare un prodotto che mi soddisfacesse: sappiate solo che alla fine ne ho trovato uno che aveva tutte le caratteristiche che cercavo, l'ho acquistato e montato. Tutto rose e fiori , finch\u00e8 il tarlo che ho citato sopra ha cominciato a scavare e farsi sentire, fino a convincermi che sarebbe stato indispensabile collegare il mio impianto alla gi\u00e0 estesa domotica di casa, basata su Home Assistant. Se esiste un \"effetto collaterale\" legato alla passione della Domotica, \u00e8 sicuramente quello di non riuscire pi\u00f9 ad accontertarsi facilmente. Ecco che cominciavano a delinearsi i contorni di un nuovo progetto, riassumibili in: collegare il sistema di antifurto esistente ad Home Assistant; scrivere del software per potenziare le funzioni dell'antifurto, alla luce del nuovo collegamento appena creato. Il primo punto merita un articolo a parte per interesse e complessit\u00e0, e nel caso che vogliate seguirmi nella tana del Bianconiglio dipende dalle caratteristiche del vostro impianto. Vi basti sapere che nella mia configurazione mi ritrovo con due entit\u00e0 legate al mio antifurto: Entit\u00e0 Funzione switch.antifurto_template azionato come switch permette di inserire e disinserire l'antifurto: il suo stato \u00e8 on ad antifurto inserito, off viceversa; binary_sensor.allarme_antifurto legato all'innesco vero e proprio dell'allarme: il suo stato \u00e8 on se la sirena sta suonando, off viceversa. Per scrivere la parte software del mio progetto ho deciso di cogliere l'occasione di continuare ad impratichirmi con AppDaemon : lo ritengo uno strumento estremamente potente e versatile, come avr\u00f2 modo di dimostrare in seguito. Premessa \u00c8 bene chiarire fin da subito che non mi considero uno sviluppatore, e la mia conoscenza di Python \u00e8 esclusivamente strumentale a soddisfare i miei scopi: ci saranno sicuramente molti modi pi\u00f9 raffinati e pythonistici per ottenere ci\u00f2 che ho ottenuto io, e mi scuso fin da subito per la mia ignoranza a riguardo. Tornando al progetto, le funzioni aggiuntive che ho deciso di inserire nel mio Antifurto 2.0 sono: accendere le luci da me specificate nel caso in cui suoni la sirena; poter inserire/disinserire l'antifurto tramite badge o generico chip RFID; avvisarmi se sto aprendo una finestra ad antifurto inserito; avvisarmi se ho dimenticato di inserire l'antifurto dopo che siamo usciti da un certo tempo, o se siamo tutti a casa e la sera non l'abbiamo ancora inserito; potenziare il sistema di notifica su telefono degli eventi, inserendo la possibilit\u00e0 di usare notifiche actionable e critical di iOS.","title":"Introduzione"},{"location":"App_Allarme/","text":"La configurazione in apps.yaml # Grazie alle caratteristiche di AppDaemon ho potuto separare il codice vero e proprio dalla sua configurazione, rendendo l'App in questione sostanzialmente \"indipendente\" dal sistema dove verr\u00e0 eseguita. Gli argomenti passati al codice saranno quindi (da inserire nel mio caso nel file apps.yaml ): 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Allarme : module : Allarme class : pyAllarme log : log_allarme indirizzo_ip : 192.168 . 1.2 token : ! secret token_appdaemon notifiche_ios : True sensore_sirena : binary_sensor . allarme_antifurto switch_antifurto : switch . antifurto_template rfid : lettore_rfid : input_text . rfid tag_abilitati : \"Alberto\" : 11 - 11 - 11 - 11 \"Alessandra\" : 22 - 22 - 22 - 22 gruppo_abitanti_casa : group . famiglia servizio_notify_push : - mobile_app_iphone_di_alberto - mobile_app_iphone_di_alessandra accendi_luci : elenco_luci : - light . bagno ... avviso_finestre : elenco_finestre : - binary_sensor . finestra_bagno ... allarme_dimenticato : minuti_attesa : 15 avviso_notturno : ora_inizio : \"22:30:00\" Il file pyAllarme.py # Iniziamo dal file Allarme.py , che contiene il codice vero e proprio interpretato da AppDaemon: vediamolo e commentiamolo un pezzo alla volta, cos\u00ec da chiarirne bene il funzionamento. 1 2 3 4 5 6 7 8 import hassapi as hass import requests as req class pyAllarme ( hass . Hass ): def initialize ( self ): self . log ( \"Inizializzazione pyAllarme!\" ) self . log ( \"Inizializzazione pyAllarme!\" , log = \"main_log\" ) Partendo dalle prime righe notiamo l'aggiunta delle librerie hassapi e requests : la prima \u00e8 indispensabile per il funzionamento di AppDaemon, mentre la seconda la utilizzeremo per la generazione delle notifiche di tipo actionable e critical che approfondiremo in seguito. Subito dopo troviamo la fase in cui dichiariamo la classe che sfrutteremo per la nostra App Allarme e definiamo la funzione di inizializzazione, indispensabile in ogni classe di AppDaemon. Nelle prime righe del file di configurazione dell'App Allarme ritroviamo i riferimenti che abbiamo appena citato: - Allarme: indica il nome dell'App che siamo configurando; - module: Allarme fa riferimento al file Allarme.py che contiene il codice della classe che utilizzeremo; - class: pyAllarme specifica che utilizzeremo proprio al classe in questione, scritta nel file (e quindi nel modulo) appena citato. Proseguiamo scrivendo nei log che \u00e8 in corso l'inizializzazione della classe pyAllarme: sfruttiamo cos\u00ec un file di log specifico per questa App ( log_allarme.log appunto, inserito nella configurazione generale dell'App alla riga log: log_allarme , che va creato prima dell'uso) dove si possano controllare tutti gli eventi collegati all'Antifurto 2.0. In questo caso il messaggio \"Inizializzazione pyAllarme!\" verr\u00e0 scritto anche nel log dell'addon di AppDaemon su Home Assistant, che viene indicato di default come main_log . Callbacks # La fase di registrazione # Subito dopo la scrittura dei log inizia la fase di inizializzazione vera e propria, composta dalla registrazione delle funzioni di callback. 1 2 3 4 5 6 7 8 9 10 11 12 ##### 1 self . listen_state ( self . toggle_antifurto , self . args [ \"switch_antifurto\" ]) ##### 2 self . listen_state ( self . sta_suonando , self . args [ \"sensore_sirena\" ], new = \"on\" ) ###### 3 if self . args [ \"notifiche_ios\" ]: evento_notifica = \"ios.notification_action_fired\" else : evento_notifica = \"mobile_app_notification_action\" self . listen_event ( self . gestisci_eventi , event = evento_notifica ) La funzione listen_state() \u00e8 una delle pi\u00f9 comunemente sfruttate in AppDaemon: permette infatti di registrare una funzione di callback (o di richiamo , in italiano) legandola al cambio di stato di un entit\u00e0 specificata. La funzione di callback non \u00e8 nient'altro che una funzione, appunto, che viene chiamata nel caso che l'entit\u00e0 osservata da listen_state cambi stato. Prendiamo come esempio la parte di codice indicata con il numero 1: il callback \u00e8 toggle_antifurto , legato ai cambiamenti di stato dell'entit\u00e0 inserita in configurazione sotto switch_antifurto (nel mio caso switch.antifurto_template , come abbiamo visto prima) e richiamata tramite self.args[] (che non fa nient'altro che andare a pescare nel file di configurazione dell'App il nome dell'entit\u00e0 che noi avremo specificato). Come avremo modo di descrivere meglio in seguito , nel momento in cui il callback viene richiamato gli vengono anche forniti una serie di informazioni su ci\u00f2 che ha causato il suo richiamo: le potremo utilizzare per costruire la nostra logica con cui far lavorare AppDaemon. Alla stessa maniera registriamo un callback sta_suonando relativamente all'entit\u00e0 specificata in configurazione sotto sensore_sirena (nel mio caso binary_sensor.allarme_antifurto ). In questo caso specifichiamo che il callback verr\u00e0 chiamato solo se lo stato in cui il sensore sirena cambia sar\u00e0 on : questa ulteriore specifica ci permette di procedere solo quando la sirena inizi a suonare, e non nel caso in cui abbia appena smesso (nuovo stato off ). La terza registrazione di questo blocco di codice permette di specificare un callback che utilizzeremo per gestire le notifiche Push provenienti dalle App di Home Assistant sui nostri cellulari. notifiche_ios \u00e8 un parametro booleano presente in configurazione, che serve a specificare se intendiamo utilizzare per le notifiche telefoni iOS ( True ) o Android ( False ). Incontriamo anche la funzione di AppDaemon listen_event : permette di registrare un callback che verr\u00e0 chiamato quando Home Assistant generer\u00e0 un evento specifico. Nel nostro caso si tratta di un evento di tipo ios.notification_action_fired o mobile_app_notification_action nel caso in cui lo generi un'App ufficiale di HA installata rispettivamente su un dispositivo iOS o Android. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ##### 4 if self . args [ \"rfid\" ]: self . listen_state ( self . gestisci_rfid , self . args [ \"rfid\" ][ \"lettore_rfid\" ]) ##### 5 if self . args [ \"avviso_finestre\" ]: for finestra in self . args [ \"avviso_finestre\" ][ \"elenco_finestre\" ]: self . listen_state ( self . finestre , finestra , new = \"on\" ) ##### 6 if self . args [ \"allarme_dimenticato\" ]: durata_secondi = self . args [ \"allarme_dimenticato\" ][ \"minuti_attesa\" ] * 60 self . listen_state ( self . dimenticanza , self . args [ \"gruppo_abitanti_casa\" ], new = \"not_home\" , duration = durata_secondi ) if self . args [ \"allarme_dimenticato\" ][ \"avviso_notturno\" ]: orario = self . args [ \"allarme_dimenticato\" ][ \"avviso_notturno\" ][ \"ora_inizio\" ] self . run_at ( self . dimenticanzanotturna , start = orario ) Il secondo ed ultimo blocco della fase di initialize del codice contiene le ultime tre registrazioni che ci interessano. La numero 4 verr\u00e0 utilizzata per inserire e disinserire l'antifurto mediante chip RFID o NFC, passando dal callback gestisci_rfid . 2 La registrazione successiva ci permette di mostrare la possibilit\u00e0 di leggere un elenco di entit\u00e0 presenti nel file di configurazione, mediante un ciclo for : essendo elenco_finestre annidato dentro le preferenze di allarme_dimenticato , dobbiamo fornire a self.args[] il percorso corretto: self.args[\"avviso_finestre\"][\"elenco_finestre\"] . Per ogni finestra viene registrato un callback ( finestre ) che verr\u00e0 chiamato ogni volta che il nuovo stato dell'entit\u00e0 sar\u00e0 pari a on . L'ultima registrazione viene usata per implementare gli avvisi che dovrebbero scattare nel caso in cui si dimentichi di inserire l'antifurto uscendo di casa, o la sera prima di andare a dormire. Nel primo caso \u00e8 necessario inserire in configurazione il numero di minuti da attendere a casa vuota prima di chiamare il callback conseguente, mentre nel secondo l'orario al quale far generare la notifica. Casa vuota Per l'informazione della casa vuota utilizziamo il gruppo gruppo abitanti casa che contiene all'interno tutte le entit\u00e0 person o device_tracker di Home Assistant riferite alle persone che vivono con noi: questo tipo di gruppo assume lo stato di home se almeno una di queste risulta a casa, e not_home se nessuna di queste risulta a casa. Le specifiche della funzione listen_state permettono l'uso di un parametro duration , che indica la durata (in secondi) per cui deve essere mantenuto il nuovo stato che assume l'entit\u00e0 monitorata: nel nostro caso la funzione di callback dimenticanza verr\u00e0 chiamata solo dopo un periodo di attesa pari a durata_secondi , ottenuta moltiplicando minuti_attesa per 60. La funzione di avviso notturno funziona invece impostando in configurazione un orario nel formato HH:MM:SS e sfruttando la funzione di pianificazione AppDaemon run_at , che chiamer\u00e0 il callback dimenticanzanotturna ogni giorno all'orario specificato. Descrizione del funzionamento # I callbacks sono la parte di codice operativa che indica ad Home Assistant una serie di operazioni di effettuare, quali servizi chiamare e cosa notificare, per esempio. La nostra attuale versione di pyAllarme ne sfrutta otto: iniziamo a vederli in dettaglio. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ##### def toggle_antifurto ( self , entity , attribute , old , new , kwargs ): if new == \"on\" : self . log ( \"Antifurto Inserito\" ) elif new == \"off\" : self . log ( \"Antifurto Disinserito\" ) ##### def notifica_mobile ( self , servizio_notify , tipo , titolo , messaggio ): url = \"http://\" + str ( self . args [ \"indirizzo_ip\" ]) + \":8123/api/services/notify/\" + servizio_notify headers = { \"Authorization\" : \"Bearer \" + str ( self . args [ \"token\" ]), \"content-type\" : \"application/json\" , } if tipo == \"actionable\" : data_json = '{\"message\":\"' + messaggio + '\",\"title\":\"' + titolo + '\",\"data\":{\"push\":{\"category\":\"allarme\"}}}' elif tipo == \"critical\" : data_json = '{\"message\":\"' + messaggio + '\",\"title\":\"' + titolo + '\",\"data\":{\"push\":{\"sound\":{\"name\":\"default\",\"critical\":\"1\",\"volume\":\"1.0\"}}}}' elif tipo == \"mix\" : data_json = '{\"message\":\"' + messaggio + '\",\"title\":\"' + titolo + '\",\"data\":{\"push\":{\"category\":\"allarme\",\"sound\":{\"name\":\"default\",\"critical\":\"1\",\"volume\":\"1.0\"}}}}' req . post ( url , headers = headers , data = data_json ) ##### def gestisci_eventi ( self , event_name , data , kwargs ): # iOS if self . args [ \"notifiche_ios\" ]: if data [ \"actionName\" ] == \"ALLARME_ON\" : self . log ( \"Attivo allarme da \" + str ( data [ \"sourceDeviceName\" ])) if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"off\" : self . call_service ( \"switch/turn_on\" , entity_id = self . args [ \"switch_antifurto\" ]) elif data [ \"actionName\" ] == \"ALLARME_OFF\" : self . log ( \"Disattivo allarme da \" + str ( data [ \"sourceDeviceName\" ])) if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"on\" : self . call_service ( \"switch/turn_off\" , entity_id = self . args [ \"switch_antifurto\" ]) # Android else : if data [ \"action\" ] == \"ALLARME_ON\" : self . log ( \"Attivo allarme\" ) if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"off\" : self . call_service ( \"switch/turn_on\" , entity_id = self . args [ \"switch_antifurto\" ]) elif data [ \"action\" ] == \"ALLARME_OFF\" : self . log ( \"Disattivo allarme\" ) if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"on\" : self . call_service ( \"switch/turn_off\" , entity_id = self . args [ \"switch_antifurto\" ]) Funzione toggle_antifurto # Il primo che incontriamo \u00e8 un callback molto semplice: lo scopo di toggle_antifurto \u00e8 quello di scrivere nel log della App quando l'antifurto viene inserito o disinserito, ai fini di debug. Come anticipato in precedenza , un callback che viene chiamato da una funzione listen_state (come specificato nella documentazione ) ha a disposizione una serie di argomenti ( entity, attribute, old, new ) da utilizzare nel suo codice. In questo caso abbiamo sfruttato il parametro new , che ci fornisce il nuovo stato che assume l'entit\u00e0 dopo il cambio: essendoci abbonati all'entit\u00e0 specificata in toggle_antifurto il ciclo if ci permette di loggare due messaggi differenti, a seconda che il nuovo stato sia on o off . Funzione notifica_mobile # La seconda funzione che incontriamo sfrutta le caratteristiche della libreria Python Request , che permette di semplificare molto l'uso di chiamate RESTful (e per questo motivo \u00e8 tra le librerie pi\u00f9 utilizzate in assoluto). Addon Se abbiamo installato AppDaemon dall'addon della Community di Home Assistant ricordiamoci di inserire Requests nella configurazione dell'addon, sotto python_packages per permetterne l'installazione. Non si tratta di un callback in questo caso, ma di una funzione che scriviamo per facilitarci la successiva gestione del meccanismo di notifica sulle App di Home Assistant su iOS ed Android. notifica_mobile , infatti, accetta servizio_notify e tipo come argomenti: il primo ci serve per specificare su quale dispositivo inviare la notifica (basandoci sul servizio notify che crea Home Assistant per ogni modalit\u00e0 di notifica aggiunta), mentre il secondo \u00e8 usato per scegliere che tipo di notifica inviare. Per quanto riguarda iOS, Apple permette di utilizzarne due tipi speciali : Tipo Caratteristiche Actionable permettono di sfruttare fino a quattro pulsanti che appaiono sotto la notifica per compiere una serie di azioni da noi specificate, o di inserire del testo in una maschera; Critical introdotte con iOS 12, sono notifiche considerate prioritarie: per questo motivo appaiono sempre in cime alle altre, e riproducono il loro suono anche se il telefono \u00e8 in modalit\u00e0 sileziosa. Sfruttare una notifica actionable implica una configurazione ulteriore che pi\u00f9 essere fatta sia a livello del file configuration.yaml sia attraverso l'App ufficiale di Home Assistant: in ogni caso vi consiglio una lettura della pagina della documentazione di HA per i passaggi esatti con cui procedere. Nel mio caso sono passato dal file di configurazione: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ios : push : categories : - name : Allarme identifier : 'allarme' actions : - identifier : 'ALLARME_ON' title : 'Allarme ON' activationMode : 'background' authenticationRequired : true destructive : false behavior : 'default' - identifier : 'ALLARME_OFF' title : 'Allarme OFF' activationMode : 'background' authenticationRequired : true destructive : true behavior : 'default' Lo scopo del codice era originariamente quello di poter sfruttare le notifiche actionable per inserire e disinserire l'antifurto, il suonare della sirena (e l'apertura finestre ad antifurto inserito) segnalato invece con notifiche critical . La funzione notifica_mobile va oltre, e permette di utilizzare anche una notifica di tipo mix : una notifica che unisce le caratteristiche di entrambe ( actionable + critical ). Per sfruttare questa funzione sar\u00e0 necessario conoscere l'indirizzo ip dell'istanza di Home Assistant, e generare un token (Profilo -> Token di accesso a lunga vita) che dovr\u00e0 essere scritto nel file di configurazione sotto token , o nel file secret.yaml di Home Assistant e richiamato con !secret token_appdaemon come nel caso indicato sopra. Funzione gestisci_eventi # Allo schiacciare dei bottoni che appiono sotto delle notifiche di tipo actionable viene generato un evento specifico nel Bus eventi di Home Assistant, del tipo gi\u00e0 citato . Lo scopo della funzione gestisci_eventi \u00e8 quello di interpretare l'evento in arrivo, ed eseguire istruzioni di conseguenza. La funzione \u00e8 divisa in due parti: una \u00e8 relativa ai dispositivi iOS, e l'altra a quelli Android. Il payload proveniente dall'evento cambia infatti a seconda dell'App che l'ha generato, sia in struttura che in contenuto: la decodifica di questi dati avviene tramite un paio di cicli if, e sfrutta la funzione di AppDaemon call_service , che permette di chiamare il servizio turn_on o turn_off sullo switch che controlla l'antifurto. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 ##### def sta_suonando ( self , entity , attribute , old , new , kwargs ): self . log ( \"Allarme! La sirena sta suonando!\" , log = \"main_log\" , level = \"WARNING\" ) self . log ( \"Allarme! La sirena sta suonando!\" , level = \"WARNING\" ) if self . sun_down (): if self . args [ \"accendi_luci\" ]: for luce in self . args [ \"accendi_luci\" ][ \"elenco_luci\" ]: self . turn_on ( luce ) self . log ( \"Allarme Sirena! Accese tutte le luci\" ) # accendi tutte le luci di casa se suona l'allarme di notte for servizio_notify in self . args [ \"servizio_notify_push\" ]: self . notifica_mobile ( servizio_notify , \"mix\" , \"Antifurto\" , \"Sirena attivata!!\" ) ##### def finestre ( self , entity , attribute , old , new , kwargs ): allarme_inserito = self . get_state ( self . args [ \"switch_antifurto\" ], default = \"off\" ) if allarme_inserito == \"on\" : self . log ( \"Avviso finestre!\" ) nome = self . get_state ( entity , attribute = \"friendly_name\" ) messaggio = \"Aperta \" + str ( nome ) + \" con Antifurto inserito!\" for servizio_notify in self . args [ \"servizio_notify_push\" ]: self . notifica_mobile ( servizio_notify , \"mix\" , \"Antifurto\" , messaggio ) ##### def dimenticanza ( self , entity , attribute , old , new , kwargs ): if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"off\" : messaggio = \"Sono passati \" + str ( self . args [ \"allarme_dimenticato\" ][ \"minuti_attesa\" ]) + \" minuti con nessuno a casa. Vuoi attivare l'antifurto?\" self . notifica_mobile ( next ( iter ( self . args [ \"servizio_notify_push\" ])), \"actionable\" , \"Antifurto\" , messaggio ) # manda la notifica solo al primo del dizionario ##### def dimenticanzanotturna ( self , kwargs ): if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"off\" : self . log ( \"Avviso dimenticanza notturna antifurto\" ) messaggio2 = \"Sono le \" + str ( self . args [ \"allarme_dimenticato\" ][ \"avviso_notturno\" ][ \"ora_inizio\" ]) + \". Vuoi attivare l'antifurto?\" self . notifica_mobile ( next ( iter ( self . args [ \"servizio_notify_push\" ])), \"actionable\" , \"Antifurto\" , messaggio2 ) ##### def gestisci_rfid ( self , entity , attribute , old , new , kwargs ): for utente , tag in self . args [ \"rfid\" ][ \"tag_abilitati\" ] . items (): if self . get_state ( self . args [ \"rfid\" ][ \"lettore_rfid\" ]) == tag : if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"off\" : self . call_service ( \"switch/turn_on\" , entity_id = self . args [ \"switch_antifurto\" ]) self . log ( \"Attivato Antifurto da tag RFID di \" + str ( utente )) elif self . get_state ( self . args [ \"switch_antifurto\" ]) == \"on\" : self . call_service ( \"switch/turn_off\" , entity_id = self . args [ \"switch_antifurto\" ]) self . log ( \"Disattivato Antifurto da tag RFID di \" + str ( utente )) Funzione sta_suonando # Lo scopo di questo callback \u00e8 semplice: nel caso che l'antifurto stia effettivamente suonando (informazione che arriva da sensore_sirena , cio\u00e8 binary_sensor.allarme_antifurto nel mio caso) la funzione: scrive l'evento in entrambi i log presenti (dell'addon e specifico dell'App Allarme); se il sole \u00e8 tramontato accende tutte le luci elencate in elenco_luci ; causa l'invio di una notifica di tipo mix in ciascuno dei servizi di notifica elencati in servizio_notify_push , con titolo \"Antifurto\" e messaggio \"Sirena attivata!!\". Se usiamo abitualmente scene con luci ad intensit\u00e0 variabile, potrebbe essere comodo sfruttare la possibilit\u00e0 della funzione turn_on di accettare parametri: potremmo ad esempio impostare un valore di brightness_pct per specificare con quale luminosit\u00e0 percentuale accendere le luci ( self.turn_on(luce, brightness_pct=100) ). Funzione finestre # La maggior parte dei (rari) falsi allarmi scattati in casa sono dovuti alla dimenticanza. Questa funzione cerca di ridurre questa possibilit\u00e0, notificando sul mio telefono e quello della mia compagna se si apre una finestra (o porta-finestra) ad antifurto inserito. 3 Il messaggio inviato da questa funzione contiene al suo interno il friendly_name della finestra che ne ha causato l'invio, sfruttando il parametro attribute della funzione get_state : \u00e8 bene ricordare che il parametro entity passato al callback in questo caso equivale al classico entity_id utilizzato da Home Assistant. Funzioni dimenticanza e dimenticanzanotturna # La prima funzione permette di unire la presence detection di Home Assistant al nostro impianto di antifurto. AppDaemon possiede diverse funzioni che lavorano su questo argomento, permettendo un controllo molto sofisticato se fosse necessario. Nel nostro caso (come spiegato in precendenza) sfruttiamo un gruppo creato ad hoc , perch\u00e9 di rapida e semplice implementazione. Una novit\u00e0 che incontriamo qui \u00e8 l'uso di next(iter(self.args[\"servizio_notify_push\"])) . Questo codice consegner\u00e0 al callback solo il primo dei servizi di notifica elencati in self.args[\"servizio_notify_push\"] , consentendo di stabilire una sorta di priorit\u00e0 all'interno dell'elenco. Questa necessit\u00e0 nasce dal fatto che non \u00e8 necessario che tutti coloro ai quali si dovrebbe notificare il suonare della sirena debbano anche poter intervenire nel caso ci fossimo dimenticati di inserirlo. Nel mio caso essendo mobile_app_iphone_di_alberto il primo della lista, solo a me verranno notificate anche le dimenticanze (ed essendo una notifica actionable potr\u00f2 inserire l'antifurto immediatamente), mentre a mobile_app_iphone_di_alessandra verr\u00e0 notificato solo il resto. Se la funzione dimenticanza si lega alla nostra presenza, la funzione dimenticanzanotturna lo fa solo all'orario che abbiamo scritto in configurazione: nell'ipotesi in cui fossimo in vacanze e non avessimo inserito l'antifurto, questo ci verrebbe notificato tutte le sere. Funzione gestisci_rfid # Per come ho configurato il mio sistema di lettura dei tag RFID, ho a disposizione su Home Assistant un input_text.rfid in cui viene scritto il codice identificativo del tag che viene letto. La funzione gestisci_rfid legge il valore di questa entit\u00e0 e la confronta con i tag specificati in configurazione come \"nome\": codice_identificativo : se c'\u00e8 una corrispondenza attiva o disattiva l'antifurto loggando chi ha effettuato il cambio di stato. Conclusioni # Mi sembra di aver mostrato le potenzialit\u00e0 di AppDaemon nell'integrare le funzioni di un classico sistema di allarme con Home Assistant. La scrittura delle funzioni che vi ho descritto nasce dalle mie particolari esigenze, e sono sicuro che le vostre non siano identiche: ci\u00f2 che vi ho spiegato dovrebbe aiutarvi a colmare questo gap e scrivere la vostra versione. Vi ricordo di consultare la documentazione del progetto per ottenere ulteriori spunti, anche tramite i numerosi esempi che l\u00ec sono riportati. Per quanto riguarda la possibilit\u00e0 di integrare AppDaemon ad altri sistemi diversi da Home Assistant, vi consiglio di dare un'occhiata alla sezione relativa al plugin MQTT, uno standard de facto nel settore della domotica. Grazie per aver letto fino a qui e buon lavoro! Vi meritate una foto di un gattino per la pazienza. Miao. Breve sitografia # AppDaemon addon per Home Assistant Homeassistant, Actionable Notifications und Appdaemon REST post from Python Libreria Requests Vi ricordo che i moduli rfid: , accendi_luci: , avviso_finestre: , allarme_dimenticato: e avviso_notturno: , il cui funzionamento vi spiegher\u00f2 in seguito, andranno configurati con False nel caso si decida di non utilizzarli. \u21a9 Per la parte hardware ho utilizzato un lettore PN532 collegato ad una Wemos D1 Mini con installato un firmware generato da ESPHome , come vedremo nella descrizione della funzione appena citata. \u21a9 Chiaramente questa feature ha senso solo se i sensori dell'antifurto sono montati all'esterno dell'abitazione, e cerca di sfruttare il tempo necessario ad aprire le persiane o le tapparelle montate all'esterno. \u21a9","title":"App Allarme"},{"location":"App_Allarme/#la-configurazione-in-appsyaml","text":"Grazie alle caratteristiche di AppDaemon ho potuto separare il codice vero e proprio dalla sua configurazione, rendendo l'App in questione sostanzialmente \"indipendente\" dal sistema dove verr\u00e0 eseguita. Gli argomenti passati al codice saranno quindi (da inserire nel mio caso nel file apps.yaml ): 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Allarme : module : Allarme class : pyAllarme log : log_allarme indirizzo_ip : 192.168 . 1.2 token : ! secret token_appdaemon notifiche_ios : True sensore_sirena : binary_sensor . allarme_antifurto switch_antifurto : switch . antifurto_template rfid : lettore_rfid : input_text . rfid tag_abilitati : \"Alberto\" : 11 - 11 - 11 - 11 \"Alessandra\" : 22 - 22 - 22 - 22 gruppo_abitanti_casa : group . famiglia servizio_notify_push : - mobile_app_iphone_di_alberto - mobile_app_iphone_di_alessandra accendi_luci : elenco_luci : - light . bagno ... avviso_finestre : elenco_finestre : - binary_sensor . finestra_bagno ... allarme_dimenticato : minuti_attesa : 15 avviso_notturno : ora_inizio : \"22:30:00\"","title":"La configurazione in apps.yaml"},{"location":"App_Allarme/#il-file-pyallarmepy","text":"Iniziamo dal file Allarme.py , che contiene il codice vero e proprio interpretato da AppDaemon: vediamolo e commentiamolo un pezzo alla volta, cos\u00ec da chiarirne bene il funzionamento. 1 2 3 4 5 6 7 8 import hassapi as hass import requests as req class pyAllarme ( hass . Hass ): def initialize ( self ): self . log ( \"Inizializzazione pyAllarme!\" ) self . log ( \"Inizializzazione pyAllarme!\" , log = \"main_log\" ) Partendo dalle prime righe notiamo l'aggiunta delle librerie hassapi e requests : la prima \u00e8 indispensabile per il funzionamento di AppDaemon, mentre la seconda la utilizzeremo per la generazione delle notifiche di tipo actionable e critical che approfondiremo in seguito. Subito dopo troviamo la fase in cui dichiariamo la classe che sfrutteremo per la nostra App Allarme e definiamo la funzione di inizializzazione, indispensabile in ogni classe di AppDaemon. Nelle prime righe del file di configurazione dell'App Allarme ritroviamo i riferimenti che abbiamo appena citato: - Allarme: indica il nome dell'App che siamo configurando; - module: Allarme fa riferimento al file Allarme.py che contiene il codice della classe che utilizzeremo; - class: pyAllarme specifica che utilizzeremo proprio al classe in questione, scritta nel file (e quindi nel modulo) appena citato. Proseguiamo scrivendo nei log che \u00e8 in corso l'inizializzazione della classe pyAllarme: sfruttiamo cos\u00ec un file di log specifico per questa App ( log_allarme.log appunto, inserito nella configurazione generale dell'App alla riga log: log_allarme , che va creato prima dell'uso) dove si possano controllare tutti gli eventi collegati all'Antifurto 2.0. In questo caso il messaggio \"Inizializzazione pyAllarme!\" verr\u00e0 scritto anche nel log dell'addon di AppDaemon su Home Assistant, che viene indicato di default come main_log .","title":"Il file pyAllarme.py"},{"location":"App_Allarme/#callbacks","text":"","title":"Callbacks"},{"location":"App_Allarme/#la-fase-di-registrazione","text":"Subito dopo la scrittura dei log inizia la fase di inizializzazione vera e propria, composta dalla registrazione delle funzioni di callback. 1 2 3 4 5 6 7 8 9 10 11 12 ##### 1 self . listen_state ( self . toggle_antifurto , self . args [ \"switch_antifurto\" ]) ##### 2 self . listen_state ( self . sta_suonando , self . args [ \"sensore_sirena\" ], new = \"on\" ) ###### 3 if self . args [ \"notifiche_ios\" ]: evento_notifica = \"ios.notification_action_fired\" else : evento_notifica = \"mobile_app_notification_action\" self . listen_event ( self . gestisci_eventi , event = evento_notifica ) La funzione listen_state() \u00e8 una delle pi\u00f9 comunemente sfruttate in AppDaemon: permette infatti di registrare una funzione di callback (o di richiamo , in italiano) legandola al cambio di stato di un entit\u00e0 specificata. La funzione di callback non \u00e8 nient'altro che una funzione, appunto, che viene chiamata nel caso che l'entit\u00e0 osservata da listen_state cambi stato. Prendiamo come esempio la parte di codice indicata con il numero 1: il callback \u00e8 toggle_antifurto , legato ai cambiamenti di stato dell'entit\u00e0 inserita in configurazione sotto switch_antifurto (nel mio caso switch.antifurto_template , come abbiamo visto prima) e richiamata tramite self.args[] (che non fa nient'altro che andare a pescare nel file di configurazione dell'App il nome dell'entit\u00e0 che noi avremo specificato). Come avremo modo di descrivere meglio in seguito , nel momento in cui il callback viene richiamato gli vengono anche forniti una serie di informazioni su ci\u00f2 che ha causato il suo richiamo: le potremo utilizzare per costruire la nostra logica con cui far lavorare AppDaemon. Alla stessa maniera registriamo un callback sta_suonando relativamente all'entit\u00e0 specificata in configurazione sotto sensore_sirena (nel mio caso binary_sensor.allarme_antifurto ). In questo caso specifichiamo che il callback verr\u00e0 chiamato solo se lo stato in cui il sensore sirena cambia sar\u00e0 on : questa ulteriore specifica ci permette di procedere solo quando la sirena inizi a suonare, e non nel caso in cui abbia appena smesso (nuovo stato off ). La terza registrazione di questo blocco di codice permette di specificare un callback che utilizzeremo per gestire le notifiche Push provenienti dalle App di Home Assistant sui nostri cellulari. notifiche_ios \u00e8 un parametro booleano presente in configurazione, che serve a specificare se intendiamo utilizzare per le notifiche telefoni iOS ( True ) o Android ( False ). Incontriamo anche la funzione di AppDaemon listen_event : permette di registrare un callback che verr\u00e0 chiamato quando Home Assistant generer\u00e0 un evento specifico. Nel nostro caso si tratta di un evento di tipo ios.notification_action_fired o mobile_app_notification_action nel caso in cui lo generi un'App ufficiale di HA installata rispettivamente su un dispositivo iOS o Android. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ##### 4 if self . args [ \"rfid\" ]: self . listen_state ( self . gestisci_rfid , self . args [ \"rfid\" ][ \"lettore_rfid\" ]) ##### 5 if self . args [ \"avviso_finestre\" ]: for finestra in self . args [ \"avviso_finestre\" ][ \"elenco_finestre\" ]: self . listen_state ( self . finestre , finestra , new = \"on\" ) ##### 6 if self . args [ \"allarme_dimenticato\" ]: durata_secondi = self . args [ \"allarme_dimenticato\" ][ \"minuti_attesa\" ] * 60 self . listen_state ( self . dimenticanza , self . args [ \"gruppo_abitanti_casa\" ], new = \"not_home\" , duration = durata_secondi ) if self . args [ \"allarme_dimenticato\" ][ \"avviso_notturno\" ]: orario = self . args [ \"allarme_dimenticato\" ][ \"avviso_notturno\" ][ \"ora_inizio\" ] self . run_at ( self . dimenticanzanotturna , start = orario ) Il secondo ed ultimo blocco della fase di initialize del codice contiene le ultime tre registrazioni che ci interessano. La numero 4 verr\u00e0 utilizzata per inserire e disinserire l'antifurto mediante chip RFID o NFC, passando dal callback gestisci_rfid . 2 La registrazione successiva ci permette di mostrare la possibilit\u00e0 di leggere un elenco di entit\u00e0 presenti nel file di configurazione, mediante un ciclo for : essendo elenco_finestre annidato dentro le preferenze di allarme_dimenticato , dobbiamo fornire a self.args[] il percorso corretto: self.args[\"avviso_finestre\"][\"elenco_finestre\"] . Per ogni finestra viene registrato un callback ( finestre ) che verr\u00e0 chiamato ogni volta che il nuovo stato dell'entit\u00e0 sar\u00e0 pari a on . L'ultima registrazione viene usata per implementare gli avvisi che dovrebbero scattare nel caso in cui si dimentichi di inserire l'antifurto uscendo di casa, o la sera prima di andare a dormire. Nel primo caso \u00e8 necessario inserire in configurazione il numero di minuti da attendere a casa vuota prima di chiamare il callback conseguente, mentre nel secondo l'orario al quale far generare la notifica. Casa vuota Per l'informazione della casa vuota utilizziamo il gruppo gruppo abitanti casa che contiene all'interno tutte le entit\u00e0 person o device_tracker di Home Assistant riferite alle persone che vivono con noi: questo tipo di gruppo assume lo stato di home se almeno una di queste risulta a casa, e not_home se nessuna di queste risulta a casa. Le specifiche della funzione listen_state permettono l'uso di un parametro duration , che indica la durata (in secondi) per cui deve essere mantenuto il nuovo stato che assume l'entit\u00e0 monitorata: nel nostro caso la funzione di callback dimenticanza verr\u00e0 chiamata solo dopo un periodo di attesa pari a durata_secondi , ottenuta moltiplicando minuti_attesa per 60. La funzione di avviso notturno funziona invece impostando in configurazione un orario nel formato HH:MM:SS e sfruttando la funzione di pianificazione AppDaemon run_at , che chiamer\u00e0 il callback dimenticanzanotturna ogni giorno all'orario specificato.","title":"La fase di registrazione"},{"location":"App_Allarme/#descrizione-del-funzionamento","text":"I callbacks sono la parte di codice operativa che indica ad Home Assistant una serie di operazioni di effettuare, quali servizi chiamare e cosa notificare, per esempio. La nostra attuale versione di pyAllarme ne sfrutta otto: iniziamo a vederli in dettaglio. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ##### def toggle_antifurto ( self , entity , attribute , old , new , kwargs ): if new == \"on\" : self . log ( \"Antifurto Inserito\" ) elif new == \"off\" : self . log ( \"Antifurto Disinserito\" ) ##### def notifica_mobile ( self , servizio_notify , tipo , titolo , messaggio ): url = \"http://\" + str ( self . args [ \"indirizzo_ip\" ]) + \":8123/api/services/notify/\" + servizio_notify headers = { \"Authorization\" : \"Bearer \" + str ( self . args [ \"token\" ]), \"content-type\" : \"application/json\" , } if tipo == \"actionable\" : data_json = '{\"message\":\"' + messaggio + '\",\"title\":\"' + titolo + '\",\"data\":{\"push\":{\"category\":\"allarme\"}}}' elif tipo == \"critical\" : data_json = '{\"message\":\"' + messaggio + '\",\"title\":\"' + titolo + '\",\"data\":{\"push\":{\"sound\":{\"name\":\"default\",\"critical\":\"1\",\"volume\":\"1.0\"}}}}' elif tipo == \"mix\" : data_json = '{\"message\":\"' + messaggio + '\",\"title\":\"' + titolo + '\",\"data\":{\"push\":{\"category\":\"allarme\",\"sound\":{\"name\":\"default\",\"critical\":\"1\",\"volume\":\"1.0\"}}}}' req . post ( url , headers = headers , data = data_json ) ##### def gestisci_eventi ( self , event_name , data , kwargs ): # iOS if self . args [ \"notifiche_ios\" ]: if data [ \"actionName\" ] == \"ALLARME_ON\" : self . log ( \"Attivo allarme da \" + str ( data [ \"sourceDeviceName\" ])) if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"off\" : self . call_service ( \"switch/turn_on\" , entity_id = self . args [ \"switch_antifurto\" ]) elif data [ \"actionName\" ] == \"ALLARME_OFF\" : self . log ( \"Disattivo allarme da \" + str ( data [ \"sourceDeviceName\" ])) if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"on\" : self . call_service ( \"switch/turn_off\" , entity_id = self . args [ \"switch_antifurto\" ]) # Android else : if data [ \"action\" ] == \"ALLARME_ON\" : self . log ( \"Attivo allarme\" ) if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"off\" : self . call_service ( \"switch/turn_on\" , entity_id = self . args [ \"switch_antifurto\" ]) elif data [ \"action\" ] == \"ALLARME_OFF\" : self . log ( \"Disattivo allarme\" ) if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"on\" : self . call_service ( \"switch/turn_off\" , entity_id = self . args [ \"switch_antifurto\" ])","title":"Descrizione del funzionamento"},{"location":"App_Allarme/#funzione-toggle_antifurto","text":"Il primo che incontriamo \u00e8 un callback molto semplice: lo scopo di toggle_antifurto \u00e8 quello di scrivere nel log della App quando l'antifurto viene inserito o disinserito, ai fini di debug. Come anticipato in precedenza , un callback che viene chiamato da una funzione listen_state (come specificato nella documentazione ) ha a disposizione una serie di argomenti ( entity, attribute, old, new ) da utilizzare nel suo codice. In questo caso abbiamo sfruttato il parametro new , che ci fornisce il nuovo stato che assume l'entit\u00e0 dopo il cambio: essendoci abbonati all'entit\u00e0 specificata in toggle_antifurto il ciclo if ci permette di loggare due messaggi differenti, a seconda che il nuovo stato sia on o off .","title":"Funzione toggle_antifurto"},{"location":"App_Allarme/#funzione-notifica_mobile","text":"La seconda funzione che incontriamo sfrutta le caratteristiche della libreria Python Request , che permette di semplificare molto l'uso di chiamate RESTful (e per questo motivo \u00e8 tra le librerie pi\u00f9 utilizzate in assoluto). Addon Se abbiamo installato AppDaemon dall'addon della Community di Home Assistant ricordiamoci di inserire Requests nella configurazione dell'addon, sotto python_packages per permetterne l'installazione. Non si tratta di un callback in questo caso, ma di una funzione che scriviamo per facilitarci la successiva gestione del meccanismo di notifica sulle App di Home Assistant su iOS ed Android. notifica_mobile , infatti, accetta servizio_notify e tipo come argomenti: il primo ci serve per specificare su quale dispositivo inviare la notifica (basandoci sul servizio notify che crea Home Assistant per ogni modalit\u00e0 di notifica aggiunta), mentre il secondo \u00e8 usato per scegliere che tipo di notifica inviare. Per quanto riguarda iOS, Apple permette di utilizzarne due tipi speciali : Tipo Caratteristiche Actionable permettono di sfruttare fino a quattro pulsanti che appaiono sotto la notifica per compiere una serie di azioni da noi specificate, o di inserire del testo in una maschera; Critical introdotte con iOS 12, sono notifiche considerate prioritarie: per questo motivo appaiono sempre in cime alle altre, e riproducono il loro suono anche se il telefono \u00e8 in modalit\u00e0 sileziosa. Sfruttare una notifica actionable implica una configurazione ulteriore che pi\u00f9 essere fatta sia a livello del file configuration.yaml sia attraverso l'App ufficiale di Home Assistant: in ogni caso vi consiglio una lettura della pagina della documentazione di HA per i passaggi esatti con cui procedere. Nel mio caso sono passato dal file di configurazione: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ios : push : categories : - name : Allarme identifier : 'allarme' actions : - identifier : 'ALLARME_ON' title : 'Allarme ON' activationMode : 'background' authenticationRequired : true destructive : false behavior : 'default' - identifier : 'ALLARME_OFF' title : 'Allarme OFF' activationMode : 'background' authenticationRequired : true destructive : true behavior : 'default' Lo scopo del codice era originariamente quello di poter sfruttare le notifiche actionable per inserire e disinserire l'antifurto, il suonare della sirena (e l'apertura finestre ad antifurto inserito) segnalato invece con notifiche critical . La funzione notifica_mobile va oltre, e permette di utilizzare anche una notifica di tipo mix : una notifica che unisce le caratteristiche di entrambe ( actionable + critical ). Per sfruttare questa funzione sar\u00e0 necessario conoscere l'indirizzo ip dell'istanza di Home Assistant, e generare un token (Profilo -> Token di accesso a lunga vita) che dovr\u00e0 essere scritto nel file di configurazione sotto token , o nel file secret.yaml di Home Assistant e richiamato con !secret token_appdaemon come nel caso indicato sopra.","title":"Funzione notifica_mobile"},{"location":"App_Allarme/#funzione-gestisci_eventi","text":"Allo schiacciare dei bottoni che appiono sotto delle notifiche di tipo actionable viene generato un evento specifico nel Bus eventi di Home Assistant, del tipo gi\u00e0 citato . Lo scopo della funzione gestisci_eventi \u00e8 quello di interpretare l'evento in arrivo, ed eseguire istruzioni di conseguenza. La funzione \u00e8 divisa in due parti: una \u00e8 relativa ai dispositivi iOS, e l'altra a quelli Android. Il payload proveniente dall'evento cambia infatti a seconda dell'App che l'ha generato, sia in struttura che in contenuto: la decodifica di questi dati avviene tramite un paio di cicli if, e sfrutta la funzione di AppDaemon call_service , che permette di chiamare il servizio turn_on o turn_off sullo switch che controlla l'antifurto. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 ##### def sta_suonando ( self , entity , attribute , old , new , kwargs ): self . log ( \"Allarme! La sirena sta suonando!\" , log = \"main_log\" , level = \"WARNING\" ) self . log ( \"Allarme! La sirena sta suonando!\" , level = \"WARNING\" ) if self . sun_down (): if self . args [ \"accendi_luci\" ]: for luce in self . args [ \"accendi_luci\" ][ \"elenco_luci\" ]: self . turn_on ( luce ) self . log ( \"Allarme Sirena! Accese tutte le luci\" ) # accendi tutte le luci di casa se suona l'allarme di notte for servizio_notify in self . args [ \"servizio_notify_push\" ]: self . notifica_mobile ( servizio_notify , \"mix\" , \"Antifurto\" , \"Sirena attivata!!\" ) ##### def finestre ( self , entity , attribute , old , new , kwargs ): allarme_inserito = self . get_state ( self . args [ \"switch_antifurto\" ], default = \"off\" ) if allarme_inserito == \"on\" : self . log ( \"Avviso finestre!\" ) nome = self . get_state ( entity , attribute = \"friendly_name\" ) messaggio = \"Aperta \" + str ( nome ) + \" con Antifurto inserito!\" for servizio_notify in self . args [ \"servizio_notify_push\" ]: self . notifica_mobile ( servizio_notify , \"mix\" , \"Antifurto\" , messaggio ) ##### def dimenticanza ( self , entity , attribute , old , new , kwargs ): if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"off\" : messaggio = \"Sono passati \" + str ( self . args [ \"allarme_dimenticato\" ][ \"minuti_attesa\" ]) + \" minuti con nessuno a casa. Vuoi attivare l'antifurto?\" self . notifica_mobile ( next ( iter ( self . args [ \"servizio_notify_push\" ])), \"actionable\" , \"Antifurto\" , messaggio ) # manda la notifica solo al primo del dizionario ##### def dimenticanzanotturna ( self , kwargs ): if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"off\" : self . log ( \"Avviso dimenticanza notturna antifurto\" ) messaggio2 = \"Sono le \" + str ( self . args [ \"allarme_dimenticato\" ][ \"avviso_notturno\" ][ \"ora_inizio\" ]) + \". Vuoi attivare l'antifurto?\" self . notifica_mobile ( next ( iter ( self . args [ \"servizio_notify_push\" ])), \"actionable\" , \"Antifurto\" , messaggio2 ) ##### def gestisci_rfid ( self , entity , attribute , old , new , kwargs ): for utente , tag in self . args [ \"rfid\" ][ \"tag_abilitati\" ] . items (): if self . get_state ( self . args [ \"rfid\" ][ \"lettore_rfid\" ]) == tag : if self . get_state ( self . args [ \"switch_antifurto\" ]) == \"off\" : self . call_service ( \"switch/turn_on\" , entity_id = self . args [ \"switch_antifurto\" ]) self . log ( \"Attivato Antifurto da tag RFID di \" + str ( utente )) elif self . get_state ( self . args [ \"switch_antifurto\" ]) == \"on\" : self . call_service ( \"switch/turn_off\" , entity_id = self . args [ \"switch_antifurto\" ]) self . log ( \"Disattivato Antifurto da tag RFID di \" + str ( utente ))","title":"Funzione gestisci_eventi"},{"location":"App_Allarme/#funzione-sta_suonando","text":"Lo scopo di questo callback \u00e8 semplice: nel caso che l'antifurto stia effettivamente suonando (informazione che arriva da sensore_sirena , cio\u00e8 binary_sensor.allarme_antifurto nel mio caso) la funzione: scrive l'evento in entrambi i log presenti (dell'addon e specifico dell'App Allarme); se il sole \u00e8 tramontato accende tutte le luci elencate in elenco_luci ; causa l'invio di una notifica di tipo mix in ciascuno dei servizi di notifica elencati in servizio_notify_push , con titolo \"Antifurto\" e messaggio \"Sirena attivata!!\". Se usiamo abitualmente scene con luci ad intensit\u00e0 variabile, potrebbe essere comodo sfruttare la possibilit\u00e0 della funzione turn_on di accettare parametri: potremmo ad esempio impostare un valore di brightness_pct per specificare con quale luminosit\u00e0 percentuale accendere le luci ( self.turn_on(luce, brightness_pct=100) ).","title":"Funzione sta_suonando"},{"location":"App_Allarme/#funzione-finestre","text":"La maggior parte dei (rari) falsi allarmi scattati in casa sono dovuti alla dimenticanza. Questa funzione cerca di ridurre questa possibilit\u00e0, notificando sul mio telefono e quello della mia compagna se si apre una finestra (o porta-finestra) ad antifurto inserito. 3 Il messaggio inviato da questa funzione contiene al suo interno il friendly_name della finestra che ne ha causato l'invio, sfruttando il parametro attribute della funzione get_state : \u00e8 bene ricordare che il parametro entity passato al callback in questo caso equivale al classico entity_id utilizzato da Home Assistant.","title":"Funzione finestre"},{"location":"App_Allarme/#funzioni-dimenticanza-e-dimenticanzanotturna","text":"La prima funzione permette di unire la presence detection di Home Assistant al nostro impianto di antifurto. AppDaemon possiede diverse funzioni che lavorano su questo argomento, permettendo un controllo molto sofisticato se fosse necessario. Nel nostro caso (come spiegato in precendenza) sfruttiamo un gruppo creato ad hoc , perch\u00e9 di rapida e semplice implementazione. Una novit\u00e0 che incontriamo qui \u00e8 l'uso di next(iter(self.args[\"servizio_notify_push\"])) . Questo codice consegner\u00e0 al callback solo il primo dei servizi di notifica elencati in self.args[\"servizio_notify_push\"] , consentendo di stabilire una sorta di priorit\u00e0 all'interno dell'elenco. Questa necessit\u00e0 nasce dal fatto che non \u00e8 necessario che tutti coloro ai quali si dovrebbe notificare il suonare della sirena debbano anche poter intervenire nel caso ci fossimo dimenticati di inserirlo. Nel mio caso essendo mobile_app_iphone_di_alberto il primo della lista, solo a me verranno notificate anche le dimenticanze (ed essendo una notifica actionable potr\u00f2 inserire l'antifurto immediatamente), mentre a mobile_app_iphone_di_alessandra verr\u00e0 notificato solo il resto. Se la funzione dimenticanza si lega alla nostra presenza, la funzione dimenticanzanotturna lo fa solo all'orario che abbiamo scritto in configurazione: nell'ipotesi in cui fossimo in vacanze e non avessimo inserito l'antifurto, questo ci verrebbe notificato tutte le sere.","title":"Funzioni dimenticanza e dimenticanzanotturna"},{"location":"App_Allarme/#funzione-gestisci_rfid","text":"Per come ho configurato il mio sistema di lettura dei tag RFID, ho a disposizione su Home Assistant un input_text.rfid in cui viene scritto il codice identificativo del tag che viene letto. La funzione gestisci_rfid legge il valore di questa entit\u00e0 e la confronta con i tag specificati in configurazione come \"nome\": codice_identificativo : se c'\u00e8 una corrispondenza attiva o disattiva l'antifurto loggando chi ha effettuato il cambio di stato.","title":"Funzione gestisci_rfid"},{"location":"App_Allarme/#conclusioni","text":"Mi sembra di aver mostrato le potenzialit\u00e0 di AppDaemon nell'integrare le funzioni di un classico sistema di allarme con Home Assistant. La scrittura delle funzioni che vi ho descritto nasce dalle mie particolari esigenze, e sono sicuro che le vostre non siano identiche: ci\u00f2 che vi ho spiegato dovrebbe aiutarvi a colmare questo gap e scrivere la vostra versione. Vi ricordo di consultare la documentazione del progetto per ottenere ulteriori spunti, anche tramite i numerosi esempi che l\u00ec sono riportati. Per quanto riguarda la possibilit\u00e0 di integrare AppDaemon ad altri sistemi diversi da Home Assistant, vi consiglio di dare un'occhiata alla sezione relativa al plugin MQTT, uno standard de facto nel settore della domotica. Grazie per aver letto fino a qui e buon lavoro! Vi meritate una foto di un gattino per la pazienza. Miao.","title":"Conclusioni"},{"location":"App_Allarme/#breve-sitografia","text":"AppDaemon addon per Home Assistant Homeassistant, Actionable Notifications und Appdaemon REST post from Python Libreria Requests Vi ricordo che i moduli rfid: , accendi_luci: , avviso_finestre: , allarme_dimenticato: e avviso_notturno: , il cui funzionamento vi spiegher\u00f2 in seguito, andranno configurati con False nel caso si decida di non utilizzarli. \u21a9 Per la parte hardware ho utilizzato un lettore PN532 collegato ad una Wemos D1 Mini con installato un firmware generato da ESPHome , come vedremo nella descrizione della funzione appena citata. \u21a9 Chiaramente questa feature ha senso solo se i sensori dell'antifurto sono montati all'esterno dell'abitazione, e cerca di sfruttare il tempo necessario ad aprire le persiane o le tapparelle montate all'esterno. \u21a9","title":"Breve sitografia"}]}